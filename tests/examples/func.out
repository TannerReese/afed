# Test user-defined functions and lambda expressions

# Variable capture
scope: {
   t: 3.56,
   f x: x + t,
},
scope.f 4 = `7.5600000000000005`,

# Multiple arguments
{
    f f x1 x2 x3 x4 : f + x1 - x2 + x3 - x4,
    f 1 2 3 4 5 = `-1`,
},

# Currying & Lambda expressions
{
    g x y: x - y * x^2,
	f g: \r: g (g r),
	f (g (1/10)) 2 = `62 / 625`,
},

# Application operator
{
   if (2 + 2 > 4) 1 $ if (2 + 3 < 3.4) 0 $ (\x: x + x) $ 4 = `8`,
   f t: t^2, f $ f $ f 1.1 = `2.143588810000001`,
},

# Lambda expressions as arguments
{
	utils.with5 $ lamb 4.1 = `5.319512195121951`,
	utils: { with5 f: f 5 },
    lamb: \x: \y: x + y / x,
},

# Substitutions inside functions
{
	t: 4.56,
    sub x: (3 * t = `13.68`) + (x = `Eval Error: Depends on non-constant argument x`),
	sub 2 = `15.68`,
},

# Function unimplemented operations
{
	f x: \y: x + 1 / y,
	f + 3 = `Eval Error: Binary operator + not implemented between types function and number`,
	4 * f = `Eval Error: Binary operator * not implemented between types number and function`,
	f 4 3 = `13 / 3`, # Works afterwards
},

# Method support
{
	num.sqrt.arity = `1`,
	atan2.arity = `2`,
	f.arity = `1`,
	g.arity = `1`,
	((\x y z: x + y + z) 3).arity = `2`,

	f x: [x, x],
	g: \y: [y, 2*y],
	f.hello = `Eval Error: Cannot call method hello on type function`,
	g.world = `Eval Error: Cannot call method world on type function`,
	f 2 = `[2, 2]`,
	g 1 = `[1, 2]`,
},

